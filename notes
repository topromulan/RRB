

libpcap in pcap-linux.c

pcap_inject_linux uses send() in fashion:
 ret = send(handle->fd, buf, size, 0);

How is the socket configured?

..

  pcap-linux.c:   sock_fd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL))
         also ..setsockopt(handle->fd, SOL_SOCKET, SO_RCVBUF,

 // seems to be how it sets promiscuos mode:

        if (!is_any_device && handle->opt.promisc) {
                memset(&mr, 0, sizeof(mr));
                mr.mr_ifindex = handle->md.ifindex;
                mr.mr_type    = PACKET_MR_PROMISC;
                if (setsockopt(sock_fd, SOL_PACKET, PACKET_ADD_MEMBERSHIP,
                    &mr, sizeof(mr)) == -1) {
                        snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
                                "setsockopt: %s", pcap_strerror(errno));
                        close(sock_fd);
                        return PCAP_ERROR;
                }
        }


it does set up RX_RING later in other parts



// binding the iface?

                handle->md.ifindex = iface_get_id(sock_fd, device,
                    handle->errbuf);
                if (handle->md.ifindex == -1) {
                        close(sock_fd);
                        return PCAP_ERROR;
                }

                if ((err = iface_bind(sock_fd, handle->md.ifindex,
                    handle->errbuf)) != 1) {
                        close(sock_fd);
                        if (err < 0)
                                return err;
                        else
                                return 0;       /* try old mechanism */
                }






when the two threads share the linked list.

the writing process updates the shared link to the first object, then removes the object.
if there was only one object in the list then the first pointer is set to null.

the reading process adds frames to the end of the list. 
if there were no items in the list then it sets the first pointer to the new first object.

maybe threads is a bitch

just set non blocking on the socket

use poll() when no packets to do



decide how we will measure time

